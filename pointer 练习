#include<stdio.h>

void test_1()
{
	int a[5] = { 1,2,3,4,5 };
	int* ptr = (int*)(&a + 1);
	printf("%d,%d", *(a + 1), *(ptr - 1));//2,5
}


//已知，结构体Test类型的变量大小是20个字节
//假设p的值是0x100000.求如下表达式
struct Test
{
	int Num;
	char* pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}* p;

void test_2()
{
	p = (struct Test*)0x100000;
	printf("%p\n", p + 0x1);//0x00100014 -- 结构体类型的大小为20个字节，转化为16进制是14，所以加14，100000变为100014，所以输出为0x00100014
	printf("%p\n", (unsigned long)p + 0x1); //unsigned表示无符号整型，举例：对于int型来说，如果有符号数的范围是-3 到 4， 那么无符号数（全为正数）的范围是0到7，不过他们都表示8个整数
											//(unsigned long)p 是把p转换成整数（而不是地址）是1048576，加1 变为1048577，转换成地址的16进制是0x00100001
	printf("%p\n", (unsigned int*)p + 0x1);//0x00100004 -- 将p转换成int*，转换成了地址，地址是16进制，加1时因为时int类型，所以地址加4,变为0x00100004
	//第一个和第三个相加1时，加的是地址，而第二个转换成了整数，在计算其地址（16进制）
	//指针+-，取决于指针类型
}

void test_3()
{
	int a[4] = { 1,2,3,4 };
	int* ptr1 = (int*)(&a + 1);//&a+1表示跳过这个数组的第一个地址，ptr1[-1]等于*(ptr+(-1)),向前移动四个字节，即为4
	int* ptr2 = (int*)((int)a + 1);//a本是数组首元素地址，强制转换成int类型，int类型整数+1时，16进制也＋1，向后移动一个字节，
									//数组a在内存的存储方式为01 00 00 00，02 00 00 00 ，03 00 00 00， 04 00 00 00，
									//向后移动一个字节就移动到了01后面，00前面，int为4个字节，显示时为00 00 00 02，输出倒过来为20 00 00 00
	printf("%x,%x", ptr1[-1], *ptr2);//4,  如果数组a的第二个元素为7，则第二个结果表示为70000000
}

void test_4()
{
	int a[3][2] = { (0,1),(2,3),(4,5) };//数组中有( , ) 这种逗号表达式，结果为最后面的，则数组a中的元素为1，3，5，0，0，0
	int* p;
	p = a[0];
	printf("%d\n", p[2]);
}

//void test_5()
//{
//	int a[5][5];
//	int(*p)[4];
//	p = a;
//	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//}

int main()
{
	test_1();
	test_2();
	test_3();
	test_4();
	/*test_5();*/

	return 0;
}
